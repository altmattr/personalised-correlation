{% extends 'base.html' %}

{% block head %}
<style>

.links line {
  stroke: #999;
}

.nodes circle {
  stroke: #fff;
  stroke-width: 0px;
}

</style>
{% endblock %}

{% block content %}
<script>
var globals = {
  node_size: 5,
  dist: 0.3,
  strength: 0.2,
  sim: null
}</script>
<p>zoom<input id = "zoom" type="range" min="1200" max="5000" oninput="set_vis_size(this)"/></p>
<p>max-dist<input id="max-dist" type="number" value="20" onchange="show_vis()"/>enable:<input id="dist-on" type="checkbox" onchange="console.log('huh');show_vis()"/></p>
<p>max-strength<input id="max-strength" type="number" value="1" onchange="show_vis()"/>enable:<input id="strength-on" type="checkbox" onchange="show_vis()"/></p>
<svg id="vis" width="1200" height="1200" viewBox="0 0 1200 1200"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>

var simulation;
var zoom = 2500;

d3.select("svg").on("scroll", function(d){console.log(d)})

function set_vis_size(elt){
  document.querySelector('svg').setAttribute('viewBox', '-'+elt.value/3+ ' -'+elt.value/3+ ' '+ elt.value+ ' '+ elt.value);
}

function show_vis(){

  //create somewhere to put the force directed graph
  var svg = d3.select("svg"),
      width = +svg.attr("width"),
      height = +svg.attr("height");

  // sync the zoom with the slider
  set_vis_size(document.getElementById("zoom"));

  // clear any existing content
  svg.selectAll("*").remove();

  d3.csv("/static/data/nodes.csv", function(nodes_data) {

    //set up the simulation 
    //nodes only for now 
    simulation = d3.forceSimulation()
              //add nodes
              .nodes(nodes_data);	
        
    //add forces
    //we're going to add a charge to each node 
    //also going to add a centering force
    simulation
        .force("charge_force", d3.forceManyBody())
        .force("center_force", d3.forceCenter(width / 2, height / 2));

    //draw circles for the nodes 
    var nodes = svg.append("g")
                  .attr("class", "nodes")
                  .selectAll("circle")
                  .data(nodes_data)
                  .enter()
                  .append("circle")
                  .attr("r", globals.node_size)
                  .attr("fill", "red")
                  .on("click", function(node){console.log(d3.select(node));})
    d3.selectAll("circle").append("svg:title").text(function(d){return d.name})

    //fetch links data 
    d3.csv("/static/data/forces.csv", function(links_data) {
      // console.log(links_data);
      //draw lines for the links 
      // var links = svg.append("g")
      //                .attr("class", "links")
      //                .selectAll("line")
      //                .data(links_data)
      //                .enter().append("line")
      //                .attr("stroke-width", function(d){console.log(d); return 0.5;});        

      //Create the link force 
      //We need the id accessor to use named sources and targets 

      var link_force =  d3.forceLink(links_data)
                          .id(function(d) { return d.name; })

      // function setDistance(md){
      //   link_force.distance(function(d){
      //               var dist = md + (d.force * md)*-1
      //               d.distance = dist
      //               return dist;
      //             })
      // }

      // function setStrength(md){
      //   link_force.strength(function(d){
      //               md*d.force
      //             });
      // }

      // if (document.getElementById("dist-on").checked) {
      //   setDistance(parseInt(document.getElementById("max-dist")));
      // }
      // if (document.getElementById("strength-on").checked){
      //   setStrength(1);
      // }
      simulation.force("link",link_force)

    function tickActions() {
      console.log("tick");
      nodes.attr("cx", function(d) { return d.x; })
          .attr("cy", function(d) { return d.y; });
      // links.attr("x1", function(d) { return d.source.x; })
      //      .attr("y1", function(d) { return d.source.y; })
      //      .attr("x2", function(d) { return d.target.x; })
      //      .attr("y2", function(d) { return d.target.y; });

    }
    //add tick instructions: 
    simulation.on("tick", tickActions );

    // register for updates
    // document.getElementById("max-dist").onchange = function(evt){
    //   console.log(evt);
    //   setDistance(parseInt(evt.srcElement.value));
    //   simulation.alpha(0.5).restart()
    // }
    // document.getElementById("max-strength").onchange = function(evt){
    //   console.log(evt);
      // setStrength(parseInt(evt.srcElement.value));
      // simulation.alpha(0.5).restart()
    // }
                    

    });
  });
}
show_vis();
</script>

{% endblock %}